# Nest.js 

## Архитектура Nest.js

### Nest.js/CLI

#### nest new

`nest new` - позволяет создать новый сервис, API или любое другое приложение и дополнительные опции. Если не передать `name`, то СLI спросит какое имя у проекта.

Команда `nest new <name> [options]` - создаёт новый проект с именем `<name>`. Опции при этом могут быть следующими:
- --dry-run - создать проект без реальных изменений.
- --skip-git - создать проект без ининциализации git репозитория.
- --skip-install - создать проект без установки зависимостей.
- --package-manager - выбрать менеджер пакетов (может быть или npm или yarn).
- --language - выбрать язык программирования, который будет использоватся в проекте (может быть или TS или JS).

#### nest generate

`nest generate` - позволяет создать новый компонент к уже существующему репозиторию по некоторой схеме. Схема это например контроллер, сервис или т.п., с некоторым именем.

Команда `nest generate <schematic> <name> [options]` - создаёт компонент по схеме <schematic> c именем <name>:
- --dry-run - создать компонент без реальных изменений.
- --project - выбор проекта для monorepo.
- --flat - создаёт компонент без вложенной папки.
- --spec - создаёт файл тестов.
- --no-spec - не создавать файл тестов.

#### nest build

`nest build` - позволяет собрать проект для `production` мода.

Команда `nest build` - собирает production вариант приложения, с некоторыми опциями:
- --path - путь до tsconfig.json если он кастомизирован, по умолчанию он будет лежать в корне проекта.
- --config - путь до nest-cli.json, аналогично с tsconfig.json.
- --watch - пересобирать проект при появлении каких-либо изменений.
- --webpack - использовать webpack для сборки.
- --webpackPath - указать путь до webpack.
- --tsc - собрать проект с помощью tsc.

### nest start

`nest start` - использует те же опции, что и `nest build`, но и ещё с дополнительными опциями.

Команда `nest start` имеет допольнительные, следующие, опции:
- --preserveWatchOutput - не очищать консоль при сборке.
- --watchAssets - следит не только за ts файлами.
- --debug - режим debug, полезен при отладке приложения.
- --exec - путь до bin файла в node.

### Модули 

Модули - это по сути строительные блоки из которых состоит приложение. В обязательном у каждого приложения на Nest.js есть хотя бы один модуль - корневой модуль, который часто называется `appModule`. Рекомендуется разделять модули по доменным областям. 

[![image.jpg](https://i.postimg.cc/JzHQzxCS/image.jpg)](https://postimg.cc/VJ1t7j6F)

В маленьких микросервисах достаточно одного модуля, в больших же сервисах и монолитах может быть вложенность три. В реальности вложенность больше трёх редко бывает. Модули поддерживают чистоту приложения, её отделимость и возможность в любой момент отрефакторить и вынести что-то в отдельным микросервис. 

#### Модуль объеденяет зависимости одной доменной области

[![image.jpg](https://i.postimg.cc/Qd7p3Mp3/image.jpg)](https://postimg.cc/6897Vtjj)

Суммарно зависимости, которые скрывает за собой модуль это:
- импорты. Это другие модули, которые текущий модуль импортирует в себя.
- контроллеры. Это http или другие протоколы контроллеры, которые позволяет взаемодействвоать с приложением.
- провайдеры. Это различные сервисы, репозитории баз данных и другие провайдеры, которые могут быть задаными.
- экспортс. Это то, что будет экспортировано. Это могут быть или провайдеры, которые будут переиспользоватся в других модулях или это реэкспорт других модулей, которые он в себя импортирует. 

Это всё хранится в декораторах, поскольку когда приложение запускается, оно начинает строить дерево зависимостей идя от корневого модуля, он собирает все импорты, провайдеры и контроллеры и строит это дерево. 

#### Использование модулей

**Первый способ - общие модули**

Общие модули можно импортировать в различные модули.

[![image.jpg](https://i.postimg.cc/43CQ7cJy/image.jpg)](https://postimg.cc/Yv3WThLB)

**Второй способ - повторный экспорт модулей**

Это когда модуль используйщийся промежуточным модулем используется ниже

[![image.jpg](https://i.postimg.cc/tJPxHSxz/image.jpg)](https://postimg.cc/sGjXYJKB)

**Третий способ - глобальные модули**

Такое может быть необходимо тогда, когда есть модуль, который необходимо использовать во всех модулях приложения. К примеру если используется подключение в базе данных во всех модулях, то можно задать модуль работы базы данных как глобальный и использовать репозиторий базы данных везде без дополнительного импорта модулей. Единственное это то, что глобальный модуль должен быть импортирован в корневой модуль. 

[![image.jpg](https://i.postimg.cc/bYBPXYyL/image.jpg)](https://postimg.cc/7b0d0kTT)

**Четвертый способ - динамические модули**

Часто, особенно при работе с базой данных, необходимо не только получить модуль базы данных, но и передать туда какую-то информацию о подключениях, пользователях и т.п., тогда необходимо использовать динамические модули. Динамические модули - это статический метод модуля, который, в результате, возвращает модуль с вложением провайдера, экспорта и импорта. По умолчанию их необходимо называть `forRoot`, если это глобальный или же `forFeature` если этот модуль использоватся в определенном скоупе модулей. 

[![image.jpg](https://i.postimg.cc/VsBt4TzY/image.jpg)](https://postimg.cc/V5v5kKST)

## Контроллеры 

Контроллер это входная точка приложения - то место, куда приходят запросы HTTP, MQTT, RabbitMQ, Kаfka и т.д.

[![image.jpg](https://i.postimg.cc/6qbFKCy6/image.jpg)](https://postimg.cc/ctYFMgRP)

Пример контроллера:

[![image.jpg](https://i.postimg.cc/15TbY0kJ/image.jpg)](https://postimg.cc/56BPXzNC)

Например у нас есть ссылка: `http://host.ru/api/product/add/1`. 
- Первое что нужно понимать, что на уровне приложения можно задать глобальный префикс апи, с помощью `app.setGlobalPrefix(<api_value>)`. Это очень удобно, поскольку, если у нас на одном домене лежит и фронт и бэк, то фронт будет стучатся на бэк по отдельно выделенному, глобальному, маршруту. 
- Второе это роутинг, который определяется уже в АПИ. Контроллеры это классы, которые декорированы, декоратором `Controller`. Внутрь этого декоратора мы можем передать путь по которому он будет доступен. 
- Третье это методы. Они должны быть декорированы соответствующим типом http запроса. 

### Типы декораторов контроллера

Типы декораторов:
- @Req() - это собственно `request` или `req` из js. Является объектом запроса. 
- @Res() - это собственно `response` или `res` из js. Является объектом ответа.

Декораторы, которые можно вытянуть через объект запроса (@Req()):
- @Params(key?: string) - строковый параметр запроса, это может быть например ID. 
- @Body(key?: string) - тело запроса.
- @Query(key?: string) - query параметры запроса.
- @Headers(name?: string) - заголовки запроса.
- @Session() - сессия пользователя.

### Разбор декораторов

[![image.jpg](https://i.postimg.cc/wv6rswNT/image.jpg)](https://postimg.cc/B8VprcNd)

### Дополнительные возможности контроллера

[![1.jpg](https://i.postimg.cc/x8ZphY4c/1.jpg)](https://postimg.cc/m1QSFxRs)

- Реагирования на Wildcard. Это способность помечать места, где можно вставлять любые символы или символы с заданой политикой.
- Свои кастомизированные HTTP коды.
- Свои кастомизированные заголовки.
- Редиректы. В принципе необходимо только в MVC приложениях. В остальных случаях, при перенаправлениях на React или другие фреймворки фронтэнда, то он будет ругатся на CORS.

[![2.jpg](https://i.postimg.cc/kXtTG0Hv/2.jpg)](https://postimg.cc/SJk6tvkn)

- Ограничение по поддомену. Если очень большое API, то это можно разграничить с помощью ограничений по поддомену. 
- Возврат Promise или Observable. Мы можем вернуть не только строку, но и ещё Promise или Observable, то есть Nest.js сам разрезолвит Promise и вернёт его как ответ. 

### Объект ответа

[![Res.jpg](https://i.postimg.cc/GmxVh0BS/Res.jpg)](https://postimg.cc/G49qq5xk)

Помимо того, что мы можем вернуть ответ с помощью `return`, мы можем его вернуть с помощью `res`. Им можно отправить статус, файл и т.д. Важно понимать, что этот response это не нодовский response. Это response именно express'а.