# Nest.js 

## Архитектура Nest.js

### Nest.js/CLI

#### nest new

`nest new` - позволяет создать новый сервис, API или любое другое приложение и дополнительные опции. Если не передать `name`, то СLI спросит какое имя у проекта.

Команда `nest new <name> [options]` - создаёт новый проект с именем `<name>`. Опции при этом могут быть следующими:
- --dry-run - создать проект без реальных изменений.
- --skip-git - создать проект без ининциализации git репозитория.
- --skip-install - создать проект без установки зависимостей.
- --package-manager - выбрать менеджер пакетов (может быть или npm или yarn).
- --language - выбрать язык программирования, который будет использоватся в проекте (может быть или TS или JS).

#### nest generate

`nest generate` - позволяет создать новый компонент к уже существующему репозиторию по некоторой схеме. Схема это например контроллер, сервис или т.п., с некоторым именем.

Команда `nest generate <schematic> <name> [options]` - создаёт компонент по схеме <schematic> c именем <name>:
- --dry-run - создать компонент без реальных изменений.
- --project - выбор проекта для monorepo.
- --flat - создаёт компонент без вложенной папки.
- --spec - создаёт файл тестов.
- --no-spec - не создавать файл тестов.

#### nest build

`nest build` - позволяет собрать проект для `production` мода.

Команда `nest build` - собирает production вариант приложения, с некоторыми опциями:
- --path - путь до tsconfig.json если он кастомизирован, по умолчанию он будет лежать в корне проекта.
- --config - путь до nest-cli.json, аналогично с tsconfig.json.
- --watch - пересобирать проект при появлении каких-либо изменений.
- --webpack - использовать webpack для сборки.
- --webpackPath - указать путь до webpack.
- --tsc - собрать проект с помощью tsc.

### nest start

`nest start` - использует те же опции, что и `nest build`, но и ещё с дополнительными опциями.

Команда `nest start` имеет допольнительные, следующие, опции:
- --preserveWatchOutput - не очищать консоль при сборке.
- --watchAssets - следит не только за ts файлами.
- --debug - режим debug, полезен при отладке приложения.
- --exec - путь до bin файла в node.

### Модули 

Модули - это по сути строительные блоки из которых состоит приложение. В обязательном у каждого приложения на Nest.js есть хотя бы один модуль - корневой модуль, который часто называется `appModule`. Рекомендуется разделять модули по доменным областям. 

[![image.jpg](https://i.postimg.cc/JzHQzxCS/image.jpg)](https://postimg.cc/VJ1t7j6F)

В маленьких микросервисах достаточно одного модуля, в больших же сервисах и монолитах может быть вложенность три. В реальности вложенность больше трёх редко бывает. Модули поддерживают чистоту приложения, её отделимость и возможность в любой момент отрефакторить и вынести что-то в отдельным микросервис. 

#### Модуль объеденяет зависимости одной доменной области

[![image.jpg](https://i.postimg.cc/Qd7p3Mp3/image.jpg)](https://postimg.cc/6897Vtjj)

Суммарно зависимости, которые скрывает за собой модуль это:
- импорты. Это другие модули, которые текущий модуль импортирует в себя.
- контроллеры. Это http или другие протоколы контроллеры, которые позволяет взаемодействвоать с приложением.
- провайдеры. Это различные сервисы, репозитории баз данных и другие провайдеры, которые могут быть задаными.
- экспортс. Это то, что будет экспортировано. Это могут быть или провайдеры, которые будут переиспользоватся в других модулях или это реэкспорт других модулей, которые он в себя импортирует. 

Это всё хранится в декораторах, поскольку когда приложение запускается, оно начинает строить дерево зависимостей идя от корневого модуля, он собирает все импорты, провайдеры и контроллеры и строит это дерево. 

#### Использование модулей

**Первый способ - общие модули**

Общие модули можно импортировать в различные модули.

[![image.jpg](https://i.postimg.cc/43CQ7cJy/image.jpg)](https://postimg.cc/Yv3WThLB)

**Второй способ - повторный экспорт модулей**

Это когда модуль используйщийся промежуточным модулем используется ниже

[![image.jpg](https://i.postimg.cc/tJPxHSxz/image.jpg)](https://postimg.cc/sGjXYJKB)

**Третий способ - глобальные модули**

Такое может быть необходимо тогда, когда есть модуль, который необходимо использовать во всех модулях приложения. К примеру если используется подключение в базе данных во всех модулях, то можно задать модуль работы базы данных как глобальный и использовать репозиторий базы данных везде без дополнительного импорта модулей. Единственное это то, что глобальный модуль должен быть импортирован в корневой модуль. 

[![image.jpg](https://i.postimg.cc/bYBPXYyL/image.jpg)](https://postimg.cc/7b0d0kTT)

**Четвертый способ - динамические модули**

Часто, особенно при работе с базой данных, необходимо не только получить модуль базы данных, но и передать туда какую-то информацию о подключениях, пользователях и т.п., тогда необходимо использовать динамические модули. Динамические модули - это статический метод модуля, который, в результате, возвращает модуль с вложением провайдера, экспорта и импорта. По умолчанию их необходимо называть `forRoot`, если это глобальный или же `forFeature` если этот модуль использоватся в определенном скоупе модулей. 

[![image.jpg](https://i.postimg.cc/VsBt4TzY/image.jpg)](https://postimg.cc/V5v5kKST)

